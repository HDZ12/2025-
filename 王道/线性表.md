1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错误信息并退出空行
```C
int DeleteList(SqlList &L){
		if(L.length==0)
			return -1;
		int temp = L.data[0];
		int a=0;
		for(int i=0;i<L.length;i++){			
			if(temp>L.data[i]){
				temp = L.data[i];				
			}
		}
		L.data[a]=L.data[length-1];
		L.length--;
		return temp;
}
```
2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法空间复杂度为$O(1)$ 
```C
void reveseList(SqList &L){
		ElemType temp=0;
		int j=0;
		for(int i=0;i<L.length/2;i++){
			j = L.length-i-1;
			temp = L.data[i];
			L.data[i] = L.data[j];
			L.data[j] = temp;
			}
}
```
3. 对长度为n的顺序表L，编写一个时间复杂度为$O(n)$ ,空间复杂度为$O(1)$ 的算法，该算法删除顺序表中所有值为x的数据元素
方法一：
```C
void DeleteX(SqList &L,int x){
		for(int i=0;i<L.length;i++){
			if(L.data[i] == x){
				L.data[i] == L.data[length-1];
				L.length--;
			}
		}
}
```
方法二：
```C
void DeleteX(SqList &L,int x){
		int k=0;
		for(int i=0;i<L.length;L++){
			if(L.data[i]!=x){
				L.data[k] = L.data[i]
				k++;
			}
		}
		L.length = k;
}
```
4. 从顺序表中删除其值在给定值s和t之间（包括s和t，要求s<t)的所有元素，若s或者t不合理或顺序表为空，则显示出错误信息并退出运行
方法一：
```C
bool DeleteList(SqList &L,ElemType s,ElemType t){
	if((s>=t)||(L.length==0))
		return false;
	int k=0;
	for(int i=0;i<L.length;i++){
		if(!(L.data[i]>=s&&L.data[i]<=t)){
			L.data[k]=L.data[i];
			k++
		}
	}
	L.length = K;
	return true;
}
```
方法二：
```C
bool Del_s_t(SqList &L,ElemType s,ElemType t){
		if(s>=t||L.length==0)
			return false;
		int k=0;
		for(int i=0;i<L.length;i++){
			if(L.data[i]>=s&&L.data[i]<=t)
				k++
			else
				L.data[i-k]=L.data[i];
		}
		L.length-=k;
		return true;
}
```
5. 从有序顺序表中删除所有重复值元素，使表中所有元素的值均不同。
```C
bool Delete_repate(SqList &L){
		if(L.length ==0)
			return false;
		int i,j;
		for( i=0,j=1;j<L.length;j++){
			if(L.data[i]!=L.data[j]){
				L.data[++i]=L.data[j];
			}
		}
		L.length = i+1;
		return true;
}
```
6. 将两个有序顺序表结合并为一个新的有序顺序表，并由函数返回结果顺序表
```C
bool Merge(SqList a,SqList b,SqList &c){
		if(a.length+b.length>c,MaxSize)
			return false;
		int i,j,k=0;
		while(i<a.length&&j<b.length){
			if(a.data[i]<b.data[j]){
				c.data[k++]=a.data[i++];
			}
			if(a.data[i]>b.data[j]){
				c.data[k++]=b.data[j++];
			}
		}
		while(i<a.length){
			c.data[k++]=a.data[i++];
		}
		whil
		return true;
}
```