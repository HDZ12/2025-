1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错误信息并退出空行
```C
int DeleteList(SqlList &L){
		if(L.length==0)
			return -1;
		int temp = L.data[0];
		int a=0;
		for(int i=0;i<L.length;i++){			
			if(temp>L.data[i]){
				temp = L.data[i];				
			}
		}
		L.data[a]=L.data[length-1];
		L.length--;
		return temp;
}
```
2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法空间复杂度为$O(1)$ 
```C
void reveseList(SqList &L){
		ElemType temp=0;
		int j=0;
		for(int i=0;i<L.length/2;i++){
			j = L.length-i-1;
			temp = L.data[i];
			L.data[i] = L.data[j];
			L.data[j] = temp;
			}
}
```
3. 对长度为n的顺序表L，编写一个时间复杂度为$O(n)$ ,空间复杂度为$O(1)$ 的算法，该算法删除顺序表中所有值为x的数据元素
方法一：
```C
void DeleteX(SqList &L,int x){
		for(int i=0;i<L.length;i++){
			if(L.data[i] == x){
				L.data[i] == L.data[length-1];
				L.length--;
			}
		}
}
```
方法二：
```C
void DeleteX(SqList &L,int x){
		int k=0;
		for(int i=0;i<L.length;L++){
			if(L.data[i]!=x){
				L.data[k] = L.data[i]
				k++;
			}
		}
		L.length = k;
}
```
4. 从顺序表中删除其值在给定值s和t之间（包括s和t，要求s<t)的所有元素，若s或者t不合理或顺序表为空，则显示出错误信息并退出运行
方法一：
```C
bool DeleteList(SqList &L,int s,int t){
	if((s>=t)||(L.length==0))
		return false;
	int k=0;
	for(int i=0;i<L.length;i++){
		if(!(L.data[i]>=s&&L.data[i]<=t)){
			L.data[k]=L.data[i];
			k++
		}
	}
	L.length = K;
	return true;
}
```